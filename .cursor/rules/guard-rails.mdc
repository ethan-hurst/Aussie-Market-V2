---
description:Use this prompt to guide all agents contributing to the MVP. Treat it as the single source of architectural truth. Do not ship changes that violate these contracts.
Objective: Build a C2C auction marketplace MVP on Supabase + SvelteKit with listings, auctions, live bidding, order/payment lifecycle, KYC, notifications, and essential security/observability.
Source of truth: The database schema is the contract. Never invent new fields/states at runtime. If you need a new state, change the schema and RLS first, then code.
Naming and IDs
Bids reference auction_id (not listing_id). All bid reads/writes must use auction_id.
Auctions reference listings.id.
Do not mix identifiers across layers (no ad-hoc mapping of listing to auction in bid code).
Allowed states and transitions
Listings: scheduled | live | ended | cancelled. If you need draft, add it to the schema + RLS first; otherwise set new listings to scheduled.
Auctions: scheduled | live | ending | ended. Only accept bids when auctions.status='live' and now < linked listing end_at.
Orders: pending_payment | paid | ready_for_handover | shipped | delivered | released | refunded | cancelled (optionally disputed if implemented end-to-end). Never use pending. Never downgrade states from webhook events.
Update all enums/types/helpers/UI to match the DB; do not ship mismatches.
Authentication and session handling
Always read the session via locals.getSession() (typed helper). Return 401 if missing. Do not construct ad-hoc session shapes.
The x-test-user-id bypass is test-only. Never depend on it in production paths.
Bidding and concurrency
Use a single authoritative RPC place_bid(auction_id, amount_cents, max_proxy_cents?) with transaction + FOR UPDATE locking and anti-sniping extension logic in SQL.
Enforce business rules: cannot bid on your own listing; KYC must be passed to bid; amount >= min increment; respect reserve prices.
Add rate limits for bid actions; surface friendly { error: string } on failures.
Auction finalization
Finalization runs via Edge Function/cron. It must be idempotent, create orders exactly once, and atomically update listing/auction statuses.
Never create orders directly from UI flows for ended auctions.
Payments and webhooks (Stripe)
In production, require real secrets (STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET). Dev defaults are allowed only in dev; fail fast otherwise.
Verify webhook signature, drop stale events, and enforce idempotency both by event_id and per (order_id, event_type) so replays never change order state twice.
Do not downgrade order states (e.g., from paid back to pending_payment). Create ledger/payment records consistently.
Keep metadata linking back to order_id and actors; no silent updates.
Realtime
Use valid Supabase realtime filters. Avoid OR inside a single filter; open multiple subscriptions if needed.
When computing time_remaining, ensure joined alias fields (e.g., listing end_at) exist; do not assume nested shapes that the select does not return.
Cleanly unsubscribe and handle reconnects.
Environment validation and startup
Use src/lib/env.ts + src/lib/startup.ts validation. In prod, failure to supply required envs must abort startup.
Never hardcode secrets; never leak service keys to the client.
Security and safety
CSRF origin check for all state-changing /api/* routes.
Enforce RLS on all tables; do not perform privileged writes from the client.
Rate limit critical endpoints: bids, listings create, payments, shipments, pickup, storage.
Sanitize and validate all inputs via shared schemas; return friendly errors via mapApiErrorToMessage.
Error handling and UX
All API errors return { error: string } with appropriate HTTP codes.
Pages use toast helpers for user feedback, no raw exception messages in prod.
Migrations and schema hygiene
Any new state/column requires: migration + indexes + RLS + tests. Do not partially apply.
Keep schema, types, and UI in lockstep; submit combined edits in one PR.
Testing minimums
Unit: bid increments/validation; anti-sniping; order state helpers.
Integration: concurrent bids (contention), finalization idempotency, webhook idempotency and no-downgrade guarantees.
E2E: sell→schedule→live→bid→end→order→pay→handover/shipping→release/refund/dispute smoke flows.
Staging canary covers pay→webhook→UI state with real Stripe test mode.
PR checklist (must pass before merge)
Schema/types/UI consistent for all states and enums; no invented states like active or pending.
All bid code uses auction_id; no listing_id lookups in bids.
Session guard via locals.getSession(); no ad-hoc session shapes.
Webhook hardened: verified signature, event age guard, idempotency table usage, per-order idempotency guard, no state downgrade.
Realtime filters valid; subscriptions cleaned up; join fields exist.
Input validation and rate limits in place; CSRF enforced.
Errors are friendly and typed; no leaking stack traces in prod.
Tests added/updated for new behavior; concurrency/webhook tests green.
Env validation passes; no dev fallbacks enabled in prod.
Deprioritized until after MVP
A11y polish beyond critical, full i18n, aggressive performance tuning, Connect payouts, shipping carriers integrations beyond manual tracking, advanced moderation, admin review UIs unless directly blocking a core flow.
globs:
alwaysApply: true
---
